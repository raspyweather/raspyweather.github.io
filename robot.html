<html>

<head>
    <style>
        body {
            padding: 0;
            margin: 0;
        }
        
        #wrapper {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        .vResizeable {
            height: 100vh;
            overflow: hidden;
            width: 50vw;
        }
        
        .hResizeable {
            height: 33.3333%;
            width: 100%;
        }
        
        #robotDisplay {
            background: orange;
            position: relative;
        }
        
        #ProgrammDisplay {
            background: red;
        }
        
        #helpDisplay {
            background: yellow;
        }
        
        #ProgrammContainer {
            background: darkorange;
            padding: 10px;
        }
        
        #ProgrammEditor {
            height: 100%;
            width: 100%;
        }
        
        #ProgrammConsole {
            background: darkred;
        }
        
        #simControls {
            width: 100%;
            bottom: 0;
            position: absolute;
            left: 0;
            right: 0;
            height: 20vmin;
            background: #ff0;
            display: flex;
        }
        
        .flexButtons {
            display: flex;
            width: 100%;
            position: relative;
        }
        
        #roboSpace {
            height: 80%;
            width: 100%;
        }
        
        .button {
            height: 80%;
            width: 25%;
            margin: 5%;
            background: #f00;
            align-self: center;
        }
        
        canvas {
            top: 0;
            left: 0;
            position: absolute;
        }
    </style>
    <link href="editor.css" rel="stylesheet" />
</head>

<body>
    <div id="wrapper">
        <div id="robotDisplay" class="vResizeable">
            <div id="roboSpace">
                <canvas id="backgroundCanvas"></canvas>
            </div>
            <div id="simControls">
                <div id="nextLevel" class="button">Next</div>
                <div id="start" class="button">Initialize</div>
                <div id="stop" class="button">SpawnRobot</div>
                <div id="speed" class="button">►►</div>
            </div>
        </div>
        <div id="ProgrammDisplay" class="vResizeable">
            <div id="helpDisplay" class="hResizeable">
                <div id="status"></div>
                <input id="calcPercentage" type="checkbox" checked>calculate Percentage</input>
                <div id="codeManagement"></div>
                <div id="codeTools" class="flexButtons">
                    <div id="NewCode" class="button">New</div>
                    <div id="SaveCode" class="button">Save</div>
                </div>
            </div>
            <div id="ProgrammContainer" class="hResizeable">
                <div id="ProgrammEditor">

                </div>
            </div>
            <div id="ProgrammConsole" class="hResizeable"></div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/ace/1.2.6/min/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="https://cdn.jsdelivr.net/ace/1.2.6/min/worker-javascript.js"></script>
    <script src="https://cdn.jsdelivr.net/ace/1.2.6/min/ext-language_tools.js"></script>
    <script src="https://cdn.jsdelivr.net/matter-js/0.12.0/matter.min.js" type="text/javascript" charset="utf-8"></script>
    <script>
        let initialStr = "\/*the startup function will get executed. Methods to move the robot are:\nrobot.rotate(radians) and robot.move(distance) which can't be used at the same time*\/ \nfunction startup(robot) \n{ robot.move();/*moves until collision*/ } \n\/*will get executed on collision. A collision aborts the current action*\/\nfunction collision() \n{ robot.rotate(robot.startup,Math.random()*Math.PI); }";
        let editor = ace.edit("ProgrammEditor");
        ace.require("ace/ext/language_tools");
        editor.setOptions({
            enableBasicAutocompletion: true
        });
        // editor.setTheme("https://cdn.jsdelivr.net/ace/1.2.6/min/theme-chaos.js");
        editor.setTheme("ace/theme/monokai");
        editor.getSession().setMode("ace/mode/javascript");
        editor.currentBranch = "default";
    </script>
    <script>
        let engine;
        let collisionMethod;
        let startupMethod;
        let render;
        let currentLevel = 0;
        let angularSpeed = 0.1;
        let Movespeed = 4;
        let pushDistance = 5;
        let minPushDistance = 2;
        let robots = [];
        let colors = [
            "rgba(128,0,0,0.1)",
            "rgba(0,128,0,0.1)",
            "rgba(0,0,128,0.1)",
            "rgba(128,128,0,0.1)",
            "rgba(128,0,128,0.1)",
            "rgba(0,128,128,0.1)"
        ];// ["#003300", "#330000", "#000033", "#003333", "#330033", "#333300"];
        let statusDiv = document.getElementById("status");
        let checkBox = document.getElementById("calcPercentage");
        let updateIntervalId;
        let canvas = document.getElementById("backgroundCanvas");
        canvas.setAttribute("width", screen.width);
        canvas.setAttribute("height", screen.height);
        let context = canvas.getContext("2d");
        let Levels = [
            {
                Rectangles: [
                    { x: 0, y: 0, h: 60, w: 300 },
                    { x: 0, y: 60, h: 300, w: 60 },
                    { x: 300, y: 0, h: 300, w: 60 },
                    { x: 60, y: 300, h: 60, w: 300 }],
                Start: { x: 150, y: 150 },
                InnerArea: {
                    Areas: [{ type: 'Rectangle', x: 60, y: 60, h: 240, w: 240 }]
                }
            },
            {
                Rectangles: [
                    { x: 0, y: 0, h: 60, w: 300 },
                    { x: 0, y: 60, h: 300, w: 60 },
                    { x: 300, y: 0, h: 300, w: 60 },
                    { x: 60, y: 300, h: 60, w: 300 },
                    { x: 150, y: 150, h: 60, w: 60 }],
                Start: { x: 100, y: 100 },
                InnerArea: {
                    Areas: [
                        { type: 'Rectangle', x: 60, y: 60, h: 90, w: 240 },
                        { type: 'Rectangle', x: 60, y: 150, h: 60, w: 90 },
                        { type: 'Rectangle', x: 210, y: 150, h: 60, w: 90 },
                        { type: 'Rectangle', x: 60, y: 210, h: 90, w: 240 }
                    ]
                }
            },
            {
                Rectangles: [
                    { x: 0, y: 0, h: 60, w: 450 },
                    { x: 0, y: 60, h: 450, w: 60 },
                    { x: 450, y: 0, h: 450, w: 60 },
                    { x: 60, y: 450, h: 60, w: 450 },
                    { x: 150, y: 150, h: 30, w: 100 },
                    { x: 200, y: 180, h: 100, w: 30 }],
                Start: { x: 100, y: 100 },
                InnerArea: {
                    Areas: [
                        { type: 'Rectangle', x: 60, y: 60, h: 90, w: 300 },
                        { type: 'Rectangle', x: 60, y: 60, h: 60, w: 90 },
                        { type: 'Rectangle', x: 60, y: 60, h: 60, w: 90 },
                        { type: 'Rectangle', x: 60, y: 210, h: 90, w: 300 }
                    ]
                }

            },


        ];
        let codeManagement = document.getElementById("codeManagement");

        document.getElementById("SaveCode").onclick = saveCodeToLocalStorage;
        document.getElementById("NewCode").onclick = newBranch;
        document.getElementById("nextLevel").onclick = function () {
            if (engine != undefined) {
                robots.forEach(x => { x.isAlive = false; });
                robots = [];
                Matter.World.clear(engine.world);
                Matter.Engine.clear(engine);
                context.clearRect(0, 0, canvas.width, canvas.height);
                currentLevel++;
                createEngine();
                context.clearRect(0, 0, canvas.width, canvas.height);
                RunSim();
            }
        };
        document.getElementById("start").onclick = function () {
            createEngine();
        };
        document.getElementById("stop").onclick = function () {
            RunSim();
        }
        checkBox.onchange = function () {
            if (updateIntervalId == undefined) {
                updateIntervalId = setInterval(function () {
                    let areas = Levels[currentLevel].InnerArea.Areas;
                    let percentages = [];
                    for (let z of areas) {
                        percentages.push(evaluate(z));
                    }
                    statusDiv.innerHTML = percentages.reduce((x, y) => { return x + y; }) / percentages.length;
                }, 100);
            }
            else {
                clearInterval(updateIntervalId);
                updateIntervalId = undefined;

            }

        }
        function loadLocalStorage() {
            let keys = [];
            for (var i = 0, len = window.localStorage.length; i < len; ++i) {
                keys.push(localStorage.key(i));
                console.log(window.localStorage.getItem(localStorage.key(i)));
            }
            if (keys.length > 0) {
                let lb = document.createElement("label");
                lb.innerHTML = "Select your current branch";
                let sel = document.createElement("select");
                lb.appendChild(sel);
                keys.map(x => {
                    let option = document.createElement("option");
                    option.innerHTML = x;
                    sel.appendChild(option);
                });
                if (keys.indexOf("default") != -1) {
                    editor.setValue(localStorage.getItem("default"));
                }
            }

        }
        loadLocalStorage();
        function newBranch() {
            let newBranch = prompt("Enter a name for your code", "branchName");
            if (newBranch == undefined || newBranch.length == 0) { return; }
            editor.branchName = newBranch;
            editor.setValue(initialStr);
            saveCodeToLocalStorage();
        }
        function saveCodeToLocalStorage() {
            console.log("code saved");
            localStorage.setItem(editor.currentBranch, editor.getValue());
        }
        //autosave
        setInterval(saveCodeToLocalStorage, 30000);



        function RunSim() {
            try {
                eval(editor.getValue());
                collisionMethod = collision;
                startupMethod = startup;
                let robot = createRobot(startupMethod, collisionMethod, Levels[currentLevel].Start);
                robots.push(robot);
                robot.startup(robot);
            } catch (error) {
                let div = document.createElement("div");
                div.className = "logEntry";
                div.innerHTML = error;
                document.getElementById("ProgrammConsole").appendChild(div);
            }
        }
        function createEngine() {
            // create an engine
            engine = Matter.Engine.create();

            // create a renderer
            render = Matter.Render.create({
                element: document.getElementById("roboSpace"),
                engine: engine
            });
            render.options.wireframes = false;
            render.options.background = "rgba(0,0,0,0)";
            render.options.showAngleIndicator = true;

            //render.options.wireframeBackground = "#020"
            // create two boxes and a ground

            engine.world.gravity.y = 0;

            let level1 = Levels[currentLevel];
            level1.Rectangles.forEach(function (element) {
                createRectWall(element);
            }, this);

            // run the engine
            Matter.Engine.run(engine);


            let collisionHandling = function (event) {
                for (let z = 0; z < event.pairs.length; z++) {
                    let bodies = [];
                    if (event.pairs[z].bodyA.label == "box") { bodies.push(event.pairs[z].bodyA); }
                    if (event.pairs[z].bodyB.label == "box") { bodies.push(event.pairs[z].bodyB); }

                    //treating robots stuck together
                    if (bodies.length > 1) {
                        for (let idx = 1; bodies.length > 1 && idx < bodies.length; idx++) {
                            let pos1 = bodies[idx - 1].position;
                            let pos2 = bodies[idx].position;
                            let direction = { x: pos1.x - pos2.x, y: pos1.y - pos2.y };
                            let absVal = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
                            let relDirection = { x: direction.x / absVal, y: direction.y / absVal };
                            Matter.Body.setPosition(bodies[idx - 1], { x: pos1.x + relDirection.x, y: pos1.y + relDirection.y });
                            Matter.Body.setPosition(bodies[idx], { x: pos2.x - relDirection.x, y: pos2.y - relDirection.y });
                        }
                    }
                    //treating wall collisions
                    else if (bodies.length == 1) {
                        bodies.forEach(function (element) {

                            let x = Math.cos(element.angle) * pushDistance;
                            let y = Math.sin(element.angle) * pushDistance;
                            if (0 < x && x < minPushDistance) {
                                x = minPushDistance;
                            }
                            else if (0 > x && x > -minPushDistance) {
                                x = -minPushDistance;
                            }
                            if (0 < y && y < minPushDistance) {
                                y = minPushDistance;
                            }
                            else if (0 > y && y > -minPushDistance) {
                                y = -minPushDistance;
                            }
                            Matter.Body.setPosition(element, {
                                x: element.position.x - x,
                                y: element.position.y - y
                            });

                        });
                    }
                    bodies.forEach(robotBody => {
                        Matter.Body.setVelocity(robotBody, { x: 0, y: 0 });
                        if (robotBody.robot.rotateFunctionFlag == true) { return; }
                        robotBody.robot.functionToCall = undefined;
                        Matter.Body.setAngularVelocity(robotBody, 0);
                        robotBody.robot.collision();
                    });
                }
            };
            Matter.Events.on(engine, 'collisionStart', collisionHandling);
            Matter.Events.on(engine, 'collisionActive', collisionHandling);
            // run the renderer
            Matter.Render.run(render);

        }
        function createRobot(startupMethod, collisionMethod, position) {
            let robot = {
                rotate: function (callback, angle) {
                    if (!robot.isAlive) { return; }
                    let thing = this.body;
                    angle = thing.angle + angle;
                    let rotateFunction = function () {
                        if (!robot.isAlive) { return; }
                        let angleToMove = thing.angle - angle;
                        if (Math.abs(angleToMove) < Movespeed) {
                            Matter.Body.setAngle(thing, angle);
                            Matter.Body.setAngularVelocity(thing, 0);
                            Matter.Body.setVelocity(thing, { x: 0, y: 0 });
                            thing.robot.functionToCall = undefined;
                            thing.robot.rotateFunctionFlag = false;
                            callback(robot);
                            return;
                        }

                        Matter.Body.setAngularVelocity(thing, (angleToMove < 0) ? angularSpeed : -angularSpeed);
                    };
                    thing.robot.functionToCall = rotateFunction;
                    thing.robot.rotateFunctionFlag = true;
                },
                move: function (callback, distance) {
                    if (!this.isAlive) { return; }
                    if (distance == undefined) {
                        distance = 999999999;
                    }
                    let thing = this.body;
                    let startPosition = thing.position;
                    let targetPosition = {
                        x: startPosition.x + Math.cos(thing.angle) * distance,
                        y: startPosition.y + Math.sin(thing.angle) * distance
                    };
                    let moveFunction = function () {
                        if (!robot.isAlive) { return; }
                        context.beginPath();

                        context.lineWidth = 5;
                        context.arc(thing.position.x, thing.position.y, thing.circleRadius, 0, 2 * Math.PI, false);
                        context.fillStyle = robot.groundColor;
                        context.fill();
                        /*context.strokeStyle = '#003300';
                        context.stroke();*/
                        let distanceToMove = Math.sqrt((startPosition.x - targetPosition.x) * (startPosition.x - targetPosition.x) + (startPosition.y - targetPosition.y) * (startPosition.y - targetPosition.y));
                        if (distanceToMove < Movespeed) {
                            Matter.Body.setVelocity(thing, { x: 0, y: 0 });
                            Matter.Body.setPosition(thing, targetPosition);
                            robot.functionToCall = undefined;
                            robot.rotateFunctionFlag = false;
                            callback(robot);
                            return;
                        }
                    };

                    Matter.Body.setVelocity(thing,
                        {
                            x: Movespeed * Math.cos((robot.body.angle)),
                            y: Movespeed * Math.sin((robot.body.angle))
                        });
                    robot.functionToCall = moveFunction;
                    robot.rotateFunctionFlag = false;
                },
                groundColor: colors[robots.length % colors.length],
                startup: startupMethod,
                collision: collisionMethod,
                isAlive: true,
                body: Matter.Bodies.circle(position.x, position.y, 20, {
                    fillStyle: 'red',
                    strokeStyle: 'blue',
                    label: "box",
                    mass: 0.1,
                    lineWidth: 8,
                    isSensor: true,
                    frictionAir: 0.0, friction: 0
                })
            };
            robot.body.robot = robot;
            robot.robot = robot;

            Matter.Events.on(engine, "beforeUpdate", function (events) {
                robot.functionToCall(robot);
            });
            Matter.World.add(engine.world, [robot.body]);
            return robot;
        }
        function onlyUnique(value, index, self) {
            return self.indexOf(value) === index;
        }
        function evaluate(area) {
            let totalCount = 0;
            let hitsCount = 0;
            //{ type: 'Rectangle', x: 60, y: 60, h: 60, w: 90 },
            if (area.type == 'Rectangle') {

                let imgData = context.getImageData(area.x, area.y, area.w, area.h);
                for (let i = 0; i < imgData.data.length; i += 4) {
                    totalCount++;
                    if (imgData.data[i] > 0) {
                        hitsCount++;
                    }
                }
            }
            return (100.0 * hitsCount) / totalCount;
        }
        function createRectWall(rect) {
            Matter.World.add(engine.world, [Matter.Bodies.rectangle(rect.x + rect.w * 0.5, rect.y + rect.h * 0.5, rect.w, rect.h, {
                isStatic: true, label: "wall", isSensor: true, render: {
                    fillStyle: 'blue',
                    lineWidth: 5,// = bump width
                    strokeStyle: 'blue'
                }
            })]);
        }

        function toDegrees(angle) {
            return angle * (180 / Math.PI);
        }
        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }
    </script>

</body>

</html>